const express = require('express')
const app = express()
const PORT = process.env.PORT || 8080;
const path = require('path')


const { _file } = require('./business/files/file')
const { DIR_URL, TEMP_CONVERT_PATH_FFMPEG, MANIFESTS_PATH } = require('./business/assets')
const { _audio } = require('./manifest/converter')


var init = async () => {
    //steps to convert files and generate manifests
    //1. list of all files.
    //2. ckeck if menifest already exists. if not go to next step.
    //3. empty ffmpeg output folder (for error free program).
    //4. compress all files using ffmpeg. If a file is already compressed do not compress it agin.
    //5. generate manifest. it will gerneate .mpd + .mp4 files.
    //6. delete compressed files generated by ffmpg.


    //implementation of the above steps--
    //1. list of all files.
    const _list = await _file.readDir(DIR_URL);
    console.log(_list)


    //2. ckeck if menifest already exists. if not go to next step.
    var promises = [];
    promises =  _list.map(path => {
        return _audio.isManifestExists(path + '.mpd').catch(err => err);
    })

    const data = await Promise.all(promises)
    console.log(data)


    //3. empty ffmpeg output folder (for error free program).
    const emptied = await _audio.deleteTempDirFiles().catch(err => console.log(err))
    if(!emptied) return;
    console.log('ffmpeg folder emptied.')

    promises = [];
    promises = data.map((isManifest, index) => {
        if(isManifest === false) {
            console.log(_list[index])
            //convert files in asyncronously
            return _audio.convertFile().catch(err => err)
        }
    })

    const converterResponse = await Promise.all(promises)
    console.log(converterResponse)



    //2. compress all files using ffmpeg. If a file is already compressed do not compress it agin.
    const input = DIR_URL  + _list[2];
    const quality = '64k';
    const output = TEMP_CONVERT_PATH_FFMPEG + _list[2] + `_${quality}`;
    // _audio.convertFiles(input, quality, output)
    // .then(data => {
    //     console.log(data)

    //     //3. generate manifest. it will gerneate .mpd + .mp4 files.
    //     _audio.gererateManifest(output, MANIFESTS_PATH + _list[2])
    //     .then(data => {
    //         console.log(data)
    //     })
    //     .catch(err => {
    //         console.log(`ERROR::>>`, err)
    //     })

    // })
    // .catch(err => {
    //     console.log(`ERROR::`, err)
    // })

    const mpdsPath = ['/f/abc.mpd', '/abc.mpd', 'new.mpd']


    // var promises = [];

    // promises =  mpdsPath.map(path => {
    //     return _audio.isManifestExists(path).catch(err => err);
    // })

    // const data = await Promise.all(promises)
    // console.log(data)
    
    
    
    // .then(data => {
    //     console.log(data)
    // })
    // .catch(err => {
    //     console.log(`ERROR ALL::`, err.message)
    // })

    //const isManifest = _audio.isManifestExists('/f/abc.mpd');
    //console.log(isManifest)




    


    //3. generate manifest. it will gerneate .mpd + .mp4 files.


    
    
}

init()






app.listen(PORT, _ => {
    console.log(`App listening on port http://localhost:${PORT}`);
    console.log('Press Ctrl+C to quit.');
  });