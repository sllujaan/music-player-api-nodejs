const express = require('express')
const app = express()
const PORT = process.env.PORT || 8080;
const path = require('path')


const { _file } = require('./business/files/file')
const { DIR_URL, TEMP_CONVERT_PATH_FFMPEG, MANIFESTS_PATH } = require('./business/assets')
const { _audio } = require('./manifest/converter')


var init = async () => {
    //steps to convert files and generate manifests
    //1. list of all files.
    //2. ckeck if menifest already exists. if not go to next step.
    //3. empty ffmpeg output folder (for error free program).
    //4. compress all files using ffmpeg. If a file is already compressed do not compress it agin.
    //5. generate manifest. it will gerneate .mpd + .mp4 files.
    //6. delete compressed files generated by ffmpg.
    //4. failed conversions and manifests--


    var FAILED_CONVERSIONS = [];
    var FAILED_MANIFESTS = [];


    //implementation of the above steps--
    //1. list of all files.
    const _list = await _file.readDir(DIR_URL);
    console.log(_list)

    //const _list = ['Alan Walker-The Spectre.mp3', 'Walker/Alan Walker-The Spectre.mp3']

    //2. ckeck if menifest already exists. if not go to next step.
    var promises = [];
    promises =  _list.map(path => {
        return _audio.isManifestExists(path + '_64kbps.mpd').catch(err => err);
    })

    const data = await Promise.all(promises)
    console.log(data)


    //3. empty ffmpeg output folder (for error free program).
    // const emptied = await _audio.deleteTempDirFiles().catch(err => console.log('ERROR => ', err))
    // //if(!emptied) return;
    // console.log('ffmpeg folder emptied.')


    //4. created empty directories for file that are in directories.
    promises = [];
    promises = _list.map(name => {
        const dir = path.parse(name).dir
        if(dir && dir !== '/') return _audio.createDir(TEMP_CONVERT_PATH_FFMPEG, dir).catch(err => err);
    })

    const dirResponse = await Promise.all(promises)
    


    //5. compress all files using ffmpeg. If a file is already compressed do not compress it agin.
    console.log('----files conversion [make sure you deleted all files in ffmeg output folder]----')
    console.log('converting files.....')
    promises = [];
    promises = data.map((isManifest, index) => {
        if(isManifest === false) {
            //console.log(_list[index])
            //convert files in asyncronously
            return _audio.convertFile(DIR_URL+_list[index], '64k', TEMP_CONVERT_PATH_FFMPEG + _list[index] + '_64kbps')
            .catch(err => {FAILED_CONVERSIONS.push(err)})
        }
    })

    const converterResponse = await Promise.all(promises)

    console.log(FAILED_CONVERSIONS)
    console.log('\n\n')

    if(FAILED_CONVERSIONS.length > 0) {
        // console.log(FAILED_CONVERSIONS)
        // console.log('\n\n')
        console.log(`${FAILED_CONVERSIONS.length} convertion/s failed.`)
    }
    else {console.log('All convertions performed successfully.')}


    //2. compress all files using ffmpeg. If a file is already compressed do not compress it agin.
    // const input = TEMP_CONVERT_PATH_FFMPEG  + _list[0] + '_64k.mp4';
    // const quality = '64k';
    // const output = MANIFESTS_PATH + _list[0] + `_${quality}`;

    console.log('generating manifests.....')
    promises = [];
    promises = _list.map(name => {

        const input = TEMP_CONVERT_PATH_FFMPEG + name + '_64kbps.mp4';
        const quality = '64kbps';
        const output = MANIFESTS_PATH + name + `_${quality}`;

        //3. generate manifest. it will gerneate .mpd + .mp4 files.
        _audio.gererateManifest(input, output).catch(err => {FAILED_MANIFESTS.push(err.message)})

    })

    const manifestsResponse = await Promise.all(promises)
    
    if(FAILED_MANIFESTS.length > 0) {
        // console.log(FAILED_MANIFESTS)
        // console.log('\n\n')
        console.log(`${FAILED_MANIFESTS.length} manifests failed to be generated`)
    }
    else {console.log('manifests generated successfully.')}


    // const input = TEMP_CONVERT_PATH_FFMPEG + _list[0] + '_64kbps.mp4';
    // const quality = '64k';
    // const output = MANIFESTS_PATH + _list[0] + `_${quality}`;

    // //3. generate manifest. it will gerneate .mpd + .mp4 files.
    // _audio.gererateManifest(input, output)
    // .then(data => {
    //     console.log(data)
    // })
    // .catch(err => {
    //     console.log(`ERROR::>>`, err)
    //     FAILED_MANIFESTS.push(err)
    // })



    //const mpdsPath = ['/f/abc.mpd', '/abc.mpd', 'new.mpd']


    // var promises = [];

    // promises =  mpdsPath.map(path => {
    //     return _audio.isManifestExists(path).catch(err => err);
    // })

    // const data = await Promise.all(promises)
    // console.log(data)
    
    
    
    // .then(data => {
    //     console.log(data)
    // })
    // .catch(err => {
    //     console.log(`ERROR ALL::`, err.message)
    // })

    //const isManifest = _audio.isManifestExists('/f/abc.mpd');
    //console.log(isManifest)




    


    //3. generate manifest. it will gerneate .mpd + .mp4 files.


    
    
}

init()






app.listen(PORT, _ => {
    console.log(`App listening on port http://localhost:${PORT}`);
    console.log('Press Ctrl+C to quit.');
  });